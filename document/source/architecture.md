# アーキテクチャ設計

本文書では、各アーキテクチャの概要、およびなぜそのアーキテクチャに至ったか、経緯を記す。

## フロー概略


```{mermaid}
stateDiagram-v2
    [*] --> App
    App --> MarkdownParser
  
    state MarkdownParser {
        [*] --> Parser
    }
    
    MarkdownParser --> Converter
    Converter --> HTMLBuilder
    
    state HTMLBuilder {
        [*] --> Builder
    }
```

## マークダウンパーサ

マークダウンの解析を責務に持つ。
ファイルを1行ずつ解釈し、マークダウン変換結果オブジェクトを生成。

マークダウンパーサは、HTMLを知ることなく、マークダウンだけで完結させたいので、
HTMLとの対応付けは中継処理へ委譲。
本処理は、マークダウンの記法の種類が何であるかを解析するに留める。

このようにオブジェクトが知る範囲を最小限にすることで、設計・テストの負荷を下げることができる。

### マークダウン変換結果オブジェクト

マークダウンの各行・要素単位で変換結果を格納。

本オブジェクトは、`Block`と`Inline`の2つの要素から構成されている。
Blockでは、ヘッダやリストなど、行単位のスタイルの種類を保持。
一方、Inlineでは、リンクや画像など、インラインでのスタイルの種類を保持。

#### データ構造

より具体的な形をイメージするため、BlockとInlineそれぞれのデータ構造を簡単に記述する。

Blockは、マークダウン変換結果オブジェクト上にリスト形式で保持される。
ヘッダのサイズ・インデント幅といった属性表現は要素のフィールドで表現。
更に、各要素は`children`をプロパティとして持ち、Inline・ネストしたブロックを格納。これにより、HTMLの階層構造を表現することができる。

Inlineは、Blockのchildrenプロパティ上で保持される。
インライン上のテキストやスタイルをプロパティとして持ち、`<a href="url">text</a>`のようなインラインスタイルを表現。

---

#### 補足: なぜBlockとInlineで分けたのか

マークダウンの解析処理は、行を単位としている。
ヘッダやリストといった、行単位のスタイルが重複することはない。例えば、ヘッダの中でリストを書くようなことはできない。

しかし、Inlineは行の中でいくつでも書くことができるので、Blockとは扱いが異なる。
Blockは、「行にどのようなスタイルを適用するか」・Inlineは、「要素にどのようなスタイルを適用するか」を意味しているので、
互いに独立している。
独立した要素は分離した方がシンプルに扱えるので、それぞれを別々に分けることにした。


### 中継処理

マークダウンの変換結果を受け取り、HTML生成処理の入力用オブジェクトを生成することを責務に持つ。

リストを具体例に考えてみる。マークダウンでは`* から始まる行であるリストのスタイル`という情報のみ保持していたが、
HTMLでは、ul・liそれぞれを表すものが必要である。
ulを表すBlockを親とし、childrenプロパティへliを表すBlockを持たせることで、よりHTMLへ近い形へ
変換結果オブジェクトを変換する。HTMLと対応する形へ解釈できれば、HTMLを生成するオブジェクトは、
入力をそのままHTMLのツリーへマッピングできるようになる。

このように、中継する役割のクラスを挟むことで、マークダウン/HTMLを処理するクラスはお互いのことを知る必要がなくなる。


### HTML組み立て処理

HTML入力オブジェクトを受け取り、HTML文字列を生成。
入力である変換結果オブジェクトが持つ階層構造を順に解釈していくことで、HTMLを文字列としてつくり出すことができる。

あとは、変換結果を呼び出し元へ返却すれば、マークダウンからHTMLへ変換された文字列が手に入る。
