# アーキテクチャ設計

本文書では各アーキテクチャの概要と、なぜそのような方法を選択したのか、簡単な経緯を記します。

## フロー概略


```{mermaid}
stateDiagram-v2
    [*] --> App
    App --> MarkdownParser
  
    state MarkdownParser {
        [*] --> Parser
    }
    
    MarkdownParser --> Converter
    Converter --> HTMLBuilder
    
    state HTMLBuilder {
        [*] --> Builder
    }
```

## マークダウンパーサ

マークダウンの解析を責務に持ちます。マークダウン文字列を入力に、`Block`・`Inline`という要素で構成されるマークダウン変換結果オブジェクトを出力します。

### Block

1つ、あるいは複数行単位の記法を表現する要素をBlockと呼ぶことにします。HTMLのBlock要素に由来しています。
例えば、コードブロックやヘッダ、リストなどはBlock要素で表現されます。

そして、Block要素はヘッダのサイズやコードブロックの言語など、HTMLの属性に相当するものを保持し、子にInline要素を持ちます。
このようにしておくことで、ヘッダであれば、ヘッダを表現するBlock要素からhタグのHTMLブロックを組み立てることができるようになります。

### Inline

1つの行に複数存在しうる、すなわちインラインで表現できる記法はInline要素と呼ぶことにします。Blockと同様、HTMLに由来しています。
例えば、アンカーや画像はInline要素で表現されます。

そして、Inline要素は属性として画像のsrcやアンカーの参照先を持ち、いずれかのBlockの子に属します。
このようにしておくことで、アンカーであれば、アンカーを表現するInline要素からaタグのHTMLインラインブロックを組み立てることができるようになります。

---

#### 補足: なぜBlockとInlineで分けたのか

マークダウンの解析処理は、基本的に行を単位としています。このとき、ヘッダやリストなどの行単位の記法が重複することはありません。例えば、ヘッダの中でリストを書くようなことはできません。

しかし、Inlineは行の中でいくつでも書くことができるので、Blockとは扱いが異なります。Blockは、記法をどのHTMLのブロック要素と対応づけるか・Inlineは、記法をどのHTMLのインライン要素と対応づけるか、を意味しているので互いに独立しています。
独立した要素は分離した方がシンプルに扱えるので、それぞれを別々に分けることにしました。

※ 処理効率も考えるとトークンにまで分けた方がよいですが、今回は処理を簡単にするためにBlock・Inline要素を導入しました。

### マークダウン変換結果オブジェクト

構成要素であるBlock・Inlineの概要が見えてきたので、マークダウン変換結果オブジェクトへ戻ります。
マークダウン変換結果オブジェクトはBlockのリストで構成されており、後続の処理でBlock要素から対応するHTMLタグを組み立てることができます。

つまり、マークダウン変換結果オブジェクトは、マークダウンの記法と対応するHTMLタグを組み立てるときの材料になります。

---

### パーサ概略

パーサのつくり出すものがイメージできるようになったので、再びパーサへ戻ります。

マークダウンパーサは、HTMLを知ることなくマークダウンだけで完結させたいので、HTMLとの対応付けは中継処理へ任せることにします。よってここでは、マークダウンの記法がどのような種類であるか解析するに留めておきます。
このようにオブジェクトが知る範囲を最小限にすることで、設計・テストの負荷を下げることを目指します。

### パーサの単位

パーサは処理をシンプルに記述するために、コードブロックのような複数行を範囲とするもの・ヘッダやリンクなど、1行で完結するものを分けて扱います。より具体的には、1つの行・複数行それぞれに合わせたパーサをつくることにします。
複数のパーサをパース処理で呼び分けることにより、各パーサは自身が処理する対象のみを知ればよいことになります。つまり、1つの行を扱うパーサではコードブロックの記法が入力として与えられた場合は...といった分岐が要らなくなります。

以上より、記法をパースする範囲に応じてパーサを切り替えることで、各パーサの責務をより小さくすることを目指します。


## 中継処理

マークダウンの変換結果を受け取り、HTML生成処理の入力用オブジェクトを生成することを責務に持ちます。
マークダウンパーサは記法が何であるかに着目しており、HTML上でどのように表現されるかには関心を持っていませんでした。これではHTMLを組み立てるときに、以下のことを考えなければなりません。

* Block/Inline要素はどのHTMLタグと対応するか
* Block/Inline要素はul/liなど範囲を持つブロック要素とどのように対応するか

リストを具体例にもう少し掘り下げてみます。マークダウンパーサでは`* から始まる行であるリスト`という情報のみ持つBlock要素が出力でした。
しかし、HTMLでは、ul・liそれぞれを表すものが必要となります。
つまり、ulを表すBlockを親とし、liを表すBlock子としたBlockが入力として求められます。これをHTMLを組み立てる処理が担うと責務が大きくなりすぎてしまうので、よりHTMLの形に近いBlock要素へ変換する処理があると望ましいです。

よって、コンバータという中継処理を新しく追加します。コンバータは、マークダウンの記法と対応するBlock要素をHTMLのタグ構造にあわせた形へ変換することが責務です。
すなわち、マークダウンを表現するBlock要素を入力に、HTMLのタグ構造を表現するBlock要素を出力します。

このように、中継する役割のクラスを挟むことで、マークダウン/HTMLを処理するクラスはお互いのことを知る必要がなくなり、シンプルに書けるようになります。


### HTML組み立て処理

HTMLタグ構造を表現するBlock要素を受け取り、HTML文字列を組み立てます。
入力である変換結果オブジェクトが持つ階層構造を順に解釈していくことで、HTMLを文字列としてつくり出すことができます。

組み立てられた文字列を返却することで、マークダウンの文字列をHTML文字列へ変換する処理が完了します。
